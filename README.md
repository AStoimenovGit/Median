# Median

Написал съм две решения - едното със std::map, другото с AVL дърво (частично имлементирано). И двете вътршно се представят като двоично - балансирани дърветеа, разликата е само в какво точно се съхранява (вж. кода). 

1. Map
Имплементира се като std::map<число, брой срещания> (нито std::map, нито std::set позволяват повторения). Вмъкването на елемент е със сложност O(ln(n)) и O(n ln(n)) за вмъкване на целия списък. Понеже, както отбелязах, се пазят елементите и техните срещания, коренът не е задължително да е средният елемент. Налага се обхождане на дървото, като се броят и събират срещанията на всеки елемент до достигане на средното число от общия брой вмъкнати елементи (вж. BaseClass::m_size), т.е. намирането на медианата е със сложност O(n)

Вмъкване O(n ln(n)) и намиране O(n)

2. AVLTree
Представя се, както личи от името му, като самобалансиращо се двоично дърво. Пазят се всички елементи, повтарящите се елементи се записват в отделни възли. (Написах го в събота вечерта (само с добавяне и обхождане, без търсене и триене), нямал съм достатъчно време за тестване и вероятно съм изпуснал някои специални случаи)

#ifndef OPTIMIZE

Вмъкването на елемент е със сложност O(ln(n)). Балансирането е с константна сложност (едно или две въртенета, всяко от които е с константна сложност). Вмъкването на целия списък е със сложност O(n ln(n)). Дървото е балансирано по дълбочина, но не и по брой елементи отляво и отдясно, затова се налага обхождане на дървото до достигане на средния елемент (вж. BaseClass::m_size). Сложността на намирането на медианата е O(n).

Вмъкване O(n ln(n)) и намиране O(n)

#else

Вмъкването на елемент е със сложност O(ln(n)). Балансирането, освен по дълбочина, е и по брой елементи отляво и отдясно, което изисква, след преместването на излишния елемент, да се балансира клонът, от който е взет този елемент. Т.е. има още O(ln(n)) балансирания в най-лошия случай. Вмъкването на целия списък е със сложност O(n ln(n)). Т.к. дървото е балансирано по брой елементи, медианата е коренът, т.е. сложността на намирането ѝ е O(1).

Вмъкване O(n ln(n)) и намиране O(1)

#endif

Други решения: 

3. Двойно свързан списък (std::list)

Добавянето е с константна сложност (списъкът знае кои са първият му и последният му елементи). Намирането на медианата вклюва копирането на списъка във вектор със сложност O(n) и сортиране на вектора със сложност O(n ln(n)).

Вмъкване O(1) и намиране O(n ln(n))

4. Вектор (std::vector)

4.1. Със сортиране при добавянето (вмъкване)

За всеки елемент изисква намиране на подходящата позиция със сложност O(ln(n)) и вмъкването му там, което е свързане с преместване на част от вектора, това със сложност O(n), т.е. за цялата операция О(n). Намирането е с константна сложност (средният елемент) O(1).

Вмъкване O(n * n) и намиране O(1)

4.2. Със добавяне отзад

Вмъкването изглежда с константна сложност, но е всъщност е линейна, т.к. резервираното място може да свърши и да се наложи да се презадели ново място, където трябва да се копират (O(n)) старите елементи и да добави новият. Намирането е свързано със сортиране със сложност O(n ln(n)) и взимане на средния елемент със сложност O(1).

Вмъкване O(n * n) и намиране O(n * ln(n))


Най-добрите решения са

##ifdef OPTIMIZE
AVLTree
#endif

и

std::list (не е имплементирано)


Нямам опит със cmake, само с Visual Studio и малко с xCode, затова предоставям решение с Visual Studio project.

13.11.2018
